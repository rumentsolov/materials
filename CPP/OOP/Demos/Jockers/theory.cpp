/*
class => обединява дефинирани от потребителя типове данни, структура от обекти / private. struct / public. Oбектите са субекти , които имат свойства и поведение и съществуват по време на изпълнение на програмата. инстанцията е самият обект, който се създава по време на изпълнение на програмата.

Конструкторите => инициализират обекти от класа. Работят като фунции, но нямат return. 

Енкапсулация =>  скриване на вътрешно състояние и операции извън класа. Осъществява се чрез public, private &  protected. Параметрите се предават чрез фунцкиии наречени Getters(const) & Setters. 
Може да бъде нарушена като обявим един клас като приятелски ( friend ) на другия -> приятелите има достъп и до private и до protected елементи.

Наследяване => наследяват се свойства и поведение на съществуващ обект в друг клас.

Полиморфизъм => когато един и същ обект  или функция се държи различно в различни класове
-Compile time - Overloading of Function, Operator, Constructors or Template metaprogramming
-Run time / Dynamic – със virtual methods ( които са поинтери)

Абстракция => предоставяне само на съществена информация на външния свят, скриване на фоновите детайли или изпълнението.

Namespaces => Наименувани групи от променливи, функции, класове и др. За избягване на конфликти с имената на променливите фунциите и класовете.

#include, #define , #if, #ifdef, #else, #pragma  - препроцесорни директиви – преди компилация, оказват как да се компилира кода. Не са част от кода. 

Темплейти на фунцкия => само при класовете, може да поемат различни контейнери.

RAII (Resource Acquisition Is Initialization)/ SBRM (Scope-Bound Resource Management) , е техника за програмиране на C++,  която обвързва жизнения цикъл на ресурс, който трябва да бъде придобит преди употреба (всичко, което съществува в ограничени количества) до живота на даден обект. Тя гарантира, че ресурсът е достъпен за всяка функция, която има достъп до обекта и при унищожаването на обекта, ресурса ще бъде освободен. Ефекта е , че няма memory leaks, яко няма изтичане на обекти.

SmartArray<T> class използва динамична памет . Не поддържа copying/moving ,assignment/move

Single responsibility – един клас отговаря за един реусрс

Правило на 3 => ако един клас се нуждае само от един от  Copy Constructor , Copy , аssignment operator= , Destructor, вероятно се нуждае от всичките
Правилото на 5 => ако един клас се нуждае само от един от  Copy Constructor , Copy Assignment operator= , Destructor , Move Constructor , Move Assignment operator=, вероятно се нуждае от всичките
Правило на 0 => STL се грижи почти за всичко и 3 и 5 не са нужни. 

Memory leak е когато има заета памет някъде из компютъра ни, до която нямаме достъп.

1 транзистор  = 1 bit ( BInary digiT ) /  0 и 1
1 byte = 8 транзистора / 8 бита , обхват от 0 до 255 / in binary 00 00 00 00 до 11 11 11 11 . В новите компютри използват 16 битова система с 16 транзистора до 65 535

Kernel :
-	Device management
-	Device Drivers
-	Memory Management
-	Process Management
-	Data management
-	Interrupt handling


Class members не могат да са референции, но могат да са поинтери
Const стойности могат да се инициализират САМО след Constructor() : инициализация {} , преди скоупа на конструктора
Като се вика функция от функция извън мейн, в класа задължително трябва да има деструктор
Копи конструкторите са за да предаваме обекти като членове на функции
Деструкторите се извикват в обратен ред , през тях не се предават параметри


Сеттери :

С референции :
Dog& set_name(const std::string& dog_name) {
this->dog_name = dog_name;
return *this; //Dereference and return }

Това позволява следния запис :  dog1.set_dog_name(“Pumba”).set_dog_breed(“blabla”).set_dog_neshto si

С поинтери :
Dog* set_name(const std::string& dog_name) {
this->dog_name = dog_name;
return this;}

Това позволява следния запис :  dog1.set_dog_name(“Pumba”)->set_dog_breed(“blabla”)->set_dog_neshto si

*/
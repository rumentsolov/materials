I.

Задача 1. Напишете програма, която чете цяло число N от стандартния вход и извежда на стандартния изход първите N прости числа. Постарайте се да измислите ефикасен алгоритъм.

Задача 2. Напишете програма, която порчита 2 цели числа от стандартния вход - sum и count. Програмата трябва да намери count на брой последователни числа, чиято сума е точно sum. Ако няма такива да изведе подходящо съобщение, че няма. Не използвайте масиви за решението на задачата!

Задача 3. Имате даден код: https://gist.github.com/poseidon4o/54356b4a9aedde824cc9ddd7dbfbda51. В коментар напишете кратък текст какво прави кода и евентуално каква задача решава. Променете кода както намерите за добре така че да го подобрите.

#include <iostream>

int main() {
	double k;
	int n;
	std::cin >> k >> n;

	const float check = 1e-6;
	float a = 1.f;
	float result = k / double(n);
	double b = 0.f;
	int c = 1;
	
	do {
		float temp = 1.f;
		for (int c = 0; c < n; c++) {
			temp *= result;
		}
		b = temp - k;
		const int now = (b > 0.f) - (b < 0);

		if (now != c) {
			a *= 0.75;
			c = now;
		}
		
		if (b > 0.f) {
			result *= 1.f/(1 + a);
		} else {
			result = result * (1.f + a);
		}
	} while(check < fabs(b));

	std::cout << result;

	return 0;
}

II.

Задача 1 
Един от начините да се прецени дали ще има дълготрайни последствия след проливен дъжд е да се намери количеството вода което се натрупва определено време след валежа. Вашата задача е да напишете програма, която по карта на терена намира колко е минималното количество валежи в литри, при което се достига определено наваляло количество вода. Програмата ви трябва да приема на входа данни за височината на терена в правоъгълна област със зададени размери. Височината се дефинира с реално число, което представлява средната височина на всеки под-регион с размер 10см на 10см.

Входът на програмата започва с две цели числа - размерите на областта в сантиметри, след което за всеки под-регион по едно реално число - неговата височина, отново в сантиметри. Накрая се подава едно реално число - минималната очаквана  височина (в см) на водата на терена след валежа.

Изходът на програмата трябва да е реално число, което представлява минималната количество валеж в литри, при което се достига такава минимална височина на задържалата се вода. Точността на резултата да е до 2 десетични знака след запетаята.

Общата сума на водата се намира като сумата от водата във всеки под-регион. Водата в един под-регион се намира от височината на региона и височината на водата в този под-регион. Един кубичен метър вода съдържа 1000 литра. Валежът е равномерен във всяка една точка.

Максималният размер на областта е 100м на 100м.

Задача 2 
Напишете програма, която да генерира тестови данни за задача 1. Трябва по зададени размери на областта да се генерира височинна карта. Направете няколко варианта за данните: 
Равнина с константна височина
Наклон в произволна посока
Редуване на върхове и долини в някоя посока (вълнообразен терен)
Случайни височини за всеки под-регион
Случайни височини за всеки под-регион без резки разлики между съседните региони. Потърсете алгоритми за реалистични височинни карти. Опишете какво точно сте реализирали.

Задача 3 
Имате даден код: https://gist.github.com/poseidon4o/5a22d1aee665c6b2b0494788ec52f929  Преработете кода, както намерите за добре за да го подобрите. В коментар опишете какво прави кода, как го постига и защо работи.

Общи
Архиви с формат .rar се приемат само ако в тях има картинка на мейл за потвърждение за покупка на лиценза за WinRar или друга съответна програма. Това важи и за други платени формати!

#include <cmath>

void moreMagic(int *&read, int count, int exp, int *&write) {
	int table[10] = {0};

	for (int c = 0; c < count; c++) {
		const int index = (read[c] / exp) % 10;
		table[index]++;
	}

	for (int c = 1; c < 10; c++) {
		table[c] += table[c - 1];
	}

	for (int c = count - 1; c >= 0; c--) {
		const int index = (read[c] / exp) % 10;
		write[table[index] - 1] = read[c];
		table[index]--;
	}

	int *a = read;
	read = write;
	write = a;
}

void magic(int *a, int count, int *b) {
	if (count < 2) {
		return;
	}
	int find = 0;
	for (int c = 1; c < count; c++) {
		if (a[c] > a[find]) {
			find = c;
		}
	}
	const int target = a[find];
	const int base = log10(target) + 1;

	for (int c = 0, exp = 1; c < base + (base & 1); c++, exp *= 10) {
		moreMagic(a, count, exp, b);
	}
}


int main() {
    int a[200], b[200];
    int n;
    std::cin >> n;
    for (int c = 0; c < n; c++) {
        std::cin >> a[c];
    }
    magic(a, n, b);
    for (int c = 0; c < n; c++) {
        std::cout << a[c] << ' ';
    }
    return 0;
}


III.

Задача 1
Имплементирайте функцията
char *stringReplace(const char *haystack, const char *needle, const char *replace);
Функцията замества всички срещания на needle в haystack с replace. Върнатият низ трябва да има памет точно заделена за дължината му.

Пример:
stringReplace("the quick brown fox jumps over the brown fence", " ", "<SPACE>") -> "the<SPACE>quick<SPACE>brown<SPACE>fox<SPACE>jumps<SPACE>over<SPACE>the<SPACE>brown<SPACE>fence"
Покажете че имплементацията ви работи коректно.

Задача 2
Имплементирайте функцията
char **stringSplit(const char *string, const char *delimiter, bool keepEmptyElements);

Функцията трябва да върне масив от под-стрингове които са получени чрез премахването на всички срещания на delimiter от string. Масивът трябва да е с точна големина като последният му елемент е nullptr. Елементите на масива трябва да са низове с точна дължина. Булевият флаг keepEmptyElements определя дали върнатият масив съдържа празни стрингове или не (в случай на последователни разделители).

Пример:
stringSplit("the  quick brown fox jumps over the brown fence ", " ", true) -> {"the", "", "quick", "brown", "fox", "jumps", "over", "the", "brown", "fence", nullptr}

Покажете че имплементацията ви работи коректно.

